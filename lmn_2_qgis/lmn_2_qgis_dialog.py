# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Lmn2QgisDialog
                                 A QGIS plugin
 Plugin allows for automatic project build needed for updating Forest Numerical Map and data management
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-11-26
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Adam Kurzawiński
        email                : adam.kurzawinski@katowice.lasy.gov.pl
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/

"""

import os
import subprocess
import shutil
import csv
import sys
import uuid
import zipfile
from os.path import basename
from qgis.core import (Qgis, QgsProject, QgsLayerTreeGroup, QgsVectorLayer, QgsRasterLayer,
    QgsCoordinateReferenceSystem, QgsSettings, QgsUnitTypes, QgsLayerTreeLayer, QgsMessageLog, QgsExpression, QgsExpressionContext, QgsExpressionContextUtils, QgsFeatureRequest, )
from PyQt5.QtCore import QUrl
from PyQt5.QtGui import QColor
from qgis.PyQt import uic
from qgis.PyQt import QtWidgets, QtGui
from PyQt5.QtWidgets import QFileDialog, QLineEdit, QMessageBox, QPushButton, QDialog, QVBoxLayout, QCheckBox, QProgressDialog, QInputDialog
from datetime import datetime

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'lmn_2_qgis_dialog_base.ui'))

class Lmn2QgisDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, iface, parent=None):
        """Constructor."""
        super(Lmn2QgisDialog, self).__init__(parent)

        self.iface = iface

        self.setupUi(self)

        # Set the window icon
        self.setWindowIcon(QtGui.QIcon(":/plugins/lmn_2_qgis/icon.png"))

        # Default working directory
        self.storage_directory = None

        # dialog elemets connections to functions
        self.pbCancel.clicked.connect(self.on_pbButton_clicked)
        self.pbClear.clicked.connect(self.on_pbButton_clicked)
        self.pbBrowseUNL.clicked.connect(self.on_pbButton_clicked)
        self.pbBrowseSLMN.clicked.connect(self.on_pbButton_clicked)
        self.pbBrowsePOCH.clicked.connect(self.on_pbButton_clicked)
        self.pbBrowseKSLMN.clicked.connect(self.on_pbButton_clicked)
        self.pbBrowseSzkice.clicked.connect(self.on_pbButton_clicked)
        self.pbLoad.clicked.connect(self.on_pbButton_clicked)
        self.pbExport.clicked.disconnect()
        self.pbExport.clicked.connect(self.on_pbExport_clicked)
        self.pbRecalcId.clicked.disconnect()
        self.pbRecalcId.clicked.connect(self.on_pbRecalcId_clicked)

###main dialog functions group

    def initGui(self):
        self.action = QtWidgets.QAction("Open Dialog", self.iface.mainWindow())
        self.action.triggered.connect(self.showDialog)
        self.iface.addPluginToMenu("&My Plugin", self.action)

    def showDialog(self):
        self.dialog = Lmn2QgisDialog(self.iface)
        self.dialog.show()

    def on_pbButton_clicked(self):
        sender = self.sender()
        button_name = sender.objectName()
        caption = None
        lineEdit = None

        match button_name:
            case 'pbCancel':
                self.leUNL.clear()
                self.leSLMN.clear()
                self.lePOCH.clear()
                self.leKSLMN.clear()
                self.leSzkice.clear()
                self.close()

            case 'pbClear':
                self.leUNL.clear()
                self.leSLMN.clear()
                self.lePOCH.clear()
                self.leKSLMN.clear()
                self.leSzkice.clear()

            case 'pbLoad':
                self.loadData()

            case 'pbBrowseUNL':
                caption = "Wskaż plik zip bazy UNL"
                lineEdit = self.leUNL
            case 'pbBrowseSLMN':
                caption = "Wskaż plik zip danych w standardzie SLMN"
                lineEdit = self.leSLMN
            case 'pbBrowsePOCH':
                caption = "Wskaż plik zip z pochodnymi"
                lineEdit = self.lePOCH
            case 'pbBrowseKSLMN':
                caption = "Wskaż plik zip kontroli standardu LMN"
                lineEdit = self.leKSLMN
            case 'pbBrowseSzkice':
                caption = "Wskaż plik zip projektu mLas"
                lineEdit = self.leSzkice

        if caption is not None and lineEdit is not None:
            directory = self.browseFiles(True, "ZIP Files (*.zip)", caption, self.storage_directory)
            lineEdit.setText(directory)


### utility functions group

    # utility to quickly open desired directory either on Win, Mac or Linux

    def open_folder(self, folder_path):
        # Normalize the folder path and make sure it is absolute
        folder_path = os.path.abspath(folder_path)

        try:
            if sys.platform.startswith('win'):  # Windows
                subprocess.Popen(f'explorer "{folder_path}"')
            elif sys.platform == 'darwin':  # MacOS
                subprocess.Popen(['open', folder_path])
            else:  # Linux or other
                subprocess.Popen(['xdg-open', folder_path])
        except Exception as e:
            # Log the error or display a message
            QgsMessageLog.logMessage(f"def open_folder - Error opening folder: {e}", "LMN2QGIS", Qgis.Critical)

    # opens browse windows, for files == true browses files, for files == false browses directories
    def browseFiles(self, files=False, file_types=None, browseCaption=None, default_directory = os.path.dirname(__file__)):
        options = QtWidgets.QFileDialog.Options()

        if files:
            file, _ = QFileDialog.getOpenFileName(
                parent=self,
                caption=browseCaption,
                directory=default_directory,
                filter=file_types,
                options=options
            )
            return file
        else:
            directory = QFileDialog.getExistingDirectory(
                parent=self,
                caption=browseCaption,
                directory=os.path.dirname(__file__),
                options=options
            )
            return directory

    def unload(self):
        if hasattr(self, 'dialog') and self.dialog:
            self.dialog.close()
            self.dialog = None

    # utility for unzipping files
    # args:
    # file : provide fileName with full directory
    # dir  : provide directory where file should be unzipped
    # def unzip_file(self, file, dir):
    #    with ZipFile(file, 'r') as zip:
    #       zip.extractall(dir)

    def unzip_file(self, zip_file_path, target_directory, folder_key):

        if folder_key == 'UNL':

            unl_target_directory = os.path.join(target_directory,'unl')
            if zipfile.is_zipfile(zip_file_path):
                try:
                    # Open the zip file
                    with zipfile.ZipFile(zip_file_path, 'r') as zip_ref:
                        # Extract all the contents into the target directory
                        zip_ref.extractall(unl_target_directory)
                        for file_name in os.listdir(unl_target_directory):
                            subdir1 = os.path.join(unl_target_directory, file_name)
                            if os.path.isdir(subdir1):
                                # Check if 'unl' exists inside the subdir1
                                unl_path = os.path.join(subdir1, 'unl')
                                if os.path.isdir(unl_path):
                                    # Move files from 'unl' folder to target_directory
                                    for each_file in os.listdir(unl_path):
                                        source_file = os.path.join(unl_path, each_file)
                                        target_file = os.path.join(target_directory, each_file)
                                        if os.path.isfile(source_file):
                                            shutil.move(source_file, target_file)
                                            QgsMessageLog.logMessage(f"def unzip_file - Moved: {source_file} → {target_file}",
                                                                     "LMN2QGIS", Qgis.Info)
                                    shutil.rmtree(unl_target_directory)

                        QgsMessageLog.logMessage(f"def unzip_file - Successfully extracted {zip_file_path} to {target_directory}", "LMN2QGIS", Qgis.Info)
                except Exception as e:
                    QgsMessageLog.logMessage(f"def unzip_file - Error unzipping the file {zip_file_path}: {e}",
                                             "LMN2QGIS", Qgis.Critical)
            else:
                QgsMessageLog.logMessage(f"def unzip_file - '{zip_file_path}' is not a valid zip file.", "LMN2QGIS", Qgis.Critical)


        elif folder_key == 'mLAS':
            QgsMessageLog.logMessage(f"Processing mLAS extraction from {zip_file_path} to {target_directory}","LMN2QGIS", Qgis.Info)

            try:
                with zipfile.ZipFile(zip_file_path, 'r') as zip_ref:
                    found_files = [file for file in zip_ref.namelist() if os.path.basename(file).startswith("szkic_")]
                    if not found_files:
                        QgsMessageLog.logMessage("No szkic_ files found in the ZIP archive.", "LMN2QGIS", Qgis.Warning)
                        return

                    for file in found_files:
                        output_path = os.path.join(target_directory, os.path.basename(file))  # Flatten extraction
                        with zip_ref.open(file) as source, open(output_path, "wb") as dest:
                            dest.write(source.read())
                        QgsMessageLog.logMessage(f"Extracted szkic_ file: {file} → {output_path}", "LMN2QGIS", Qgis.Info)
            except Exception as e:
                QgsMessageLog.logMessage(f"Error extracting szkic_ files: {e}", "LMN2QGIS", Qgis.Critical)
        else:
            if zipfile.is_zipfile(zip_file_path):
                try:
                    # Open the zip file
                    with zipfile.ZipFile(zip_file_path, 'r') as zip_ref:
                        # Extract all the contents into the target directory
                        zip_ref.extractall(target_directory)
                        QgsMessageLog.logMessage(f"Successfully extracted {zip_file_path} to {target_directory}",
                                                 "LMN2QGIS", Qgis.Info)
                except Exception as e:
                    QgsMessageLog.logMessage(f"Error unzipping the file {zip_file_path}: {e}", "LMN2QGIS",
                                             Qgis.Critical)
            else:
                QgsMessageLog.logMessage(f"{zip_file_path} is not a valid zip file.", "LMN2QGIS",
                                         Qgis.Critical)

    def loadData(self):
        current_project = QgsProject.instance().fileName()
        project_dir = os.path.dirname(current_project)

        # Save currently opened project if one is open
        if current_project:
            QgsProject.instance().write()

        # Clear the current project
        QgsProject.instance().clear()

        # Data paths from QLineEdits
        dataPaths = {
            'UNL': self.leUNL.text(),
            'SLMN': self.leSLMN.text(),
            'POCH': self.lePOCH.text(),
            'KSLMN': self.leKSLMN.text(),
            'mLAS': self.leSzkice.text()
        }

        unzip_directories = {
            'UNL': os.path.join('001_UNL','unl'),
            'SLMN': '002_SLMN',
            'POCH': '003_POCH',
            'KSLMN': '004_KontroleSLMN',
            'mLAS': '005_ObiektySzkicownika'
        }

        # Unzip files into their respective directories
        for key, path in dataPaths.items():
            if path:  # Only process non-empty paths
                # Join the project directory with the sub-directory name
                directory = os.path.join(project_dir, unzip_directories.get(key))
                if directory:
                    try:
                        # Ensure dir exists
                        if not os.path.exists(directory):
                            os.makedirs(directory)
                        QgsMessageLog.logMessage(f"Unzipping {path} into {directory}",
                                                 "LMN2QGIS", Qgis.Info)
                        self.unzip_file(path, directory, key)  # Pass the key to handle special UNL case
                    except Exception as e:
                        QgsMessageLog.logMessage(f"Error unzipping {path}: {e}",
                                                 "LMN2QGIS", Qgis.Critical)

        # Reload the project if it was previously open
        if current_project:
            project_instance = QgsProject.instance()
            if not project_instance.read(current_project):
                QgsMessageLog.logMessage("Failed to reload the project file.","LMN2QGIS", Qgis.Critical)
            else:
                QgsMessageLog.logMessage("Project reloaded successfully.", "LMN2QGIS", Qgis.Info)

        # Get the layer by name
        layer_name = 'a_oddz_pol'  # Replace with your layer name
        layer = QgsProject.instance().mapLayersByName(layer_name)

        if layer:
            layer = layer[0]  # Get the first layer with that name
            # Get the extent of the layer
            extent = layer.extent()

            # Get the map canvas
            canvas = self.iface.mapCanvas()

            # Set the canvas extent to the layer's extent
            canvas.setExtent(extent)

            # Refresh the canvas to update the view
            canvas.refresh()
        else:
            print(f"Layer '{layer_name}' not found.")

    def on_pbExport_clicked(self):
        QgsMessageLog.logMessage("on_pbExport_clicked - Start", "LMN2QGIS", Qgis.Info)

        project_directory = os.path.dirname(QgsProject.instance().fileName())

        data_to_export_directory = os.path.join(project_directory, "002_SLMN")
        export_directory = os.path.join(project_directory, "000_DoImportuSILP")

        if not os.path.isdir(export_directory):
            os.makedirs(export_directory)

        if not os.path.isdir(data_to_export_directory):
            self.show_popup("Błąd", "Folder 002_SLMN nie istnieje!")
            return

        if len(os.listdir(data_to_export_directory)) == 0:
            self.show_popup("Błąd", "Folder 002_SLMN jest pusty!")
            return

        shapefile_names = {
            "a_pnsw_pow", "a_oddz_pol", "a_wydz_pol",
            "a_uzyt_pol", "a_dzew_pol", "a_les_pol"
        }

        # **User choice: Zip entire folder or specific shapefiles**
        choice = self.show_decision_msg_box("Export do zip", f"Wybierz 'Eksportuj wybrane' aby wyeksportować paczkę zawierającą tylko pliki warstw\n\n{shapefile_names}.\n\nOpcja 'Pełny eksport' utworzy paczkę zawierającą wszystkie pliki SLMN", "Eksportuj wybrane", "Pełny eksport")

        # **Zip file name with timestamp**
        time_tag = datetime.now().strftime("%Y%m%d_%H.%M.%S.zip")
        zip_file_path = os.path.join(export_directory, time_tag)

        if choice == False:  # **User chose to zip entire folder**
            QgsMessageLog.logMessage(f"Zipping entire folder: {data_to_export_directory}", "LMN2QGIS", Qgis.Info)
            with zipfile.ZipFile(zip_file_path, "w", zipfile.ZIP_DEFLATED) as zipf:
                for root, _, files in os.walk(data_to_export_directory):
                    for file in files:
                        file_path = os.path.join(root, file)
                        arcname = os.path.relpath(file_path, data_to_export_directory)
                        zipf.write(file_path, arcname)
                        QgsMessageLog.logMessage(f"Added file: {arcname}", "LMN2QGIS", Qgis.Info)

        else:  # **User chose to zip specific shapefiles**
            QgsMessageLog.logMessage("Zipping only selected SHP files...", "LMN2QGIS", Qgis.Info)
            with zipfile.ZipFile(zip_file_path, "w", zipfile.ZIP_DEFLATED) as zipf:
                added_files = 0
                for root, _, files in os.walk(data_to_export_directory):
                    for file in files:
                        file_base, ext = os.path.splitext(file)
                        if ext.lower() in {".shp", ".dbf", ".shx", ".prj"} and file_base.lower() in shapefile_names:
                            file_path = os.path.join(root, file)
                            arcname = os.path.relpath(file_path, data_to_export_directory)
                            zipf.write(file_path, arcname)
                            added_files += 1
                            QgsMessageLog.logMessage(f"Added file: {arcname}", "LMN2QGIS", Qgis.Info)

                if added_files == 0:
                    QMessageBox.warning(None, "Błąd", "Nie znaleziono plików SHP do eksportu!")
                    return

        QgsMessageLog.logMessage(f"Zip file created: {zip_file_path}", "LMN2QGIS", Qgis.Info)

        # **Open folder in file explorer**
        if os.name == "nt":  # Windows
            subprocess.call(("cmd", "/c", "start", "", export_directory))
        elif os.name == "posix":  # macOS / Linux
            subprocess.call(("open", export_directory)) if sys.platform == "darwin" else subprocess.call(("xdg-open", export_directory))

        QgsMessageLog.logMessage("on_pbExport_clicked - End", "LMN2QGIS", Qgis.Info)


    def on_pbRecalcId_clicked(self):

        hint_msg = "Ta funkcja zaktualizuje pole 'id' wskazanych warstw stosując wyrażenie '$id + 1'.\nZaleca się uruchomienie tej funkcji przed importem do SILP jeśli" \
                   "w trakcie edycji warstwy usuwano lub dodawano obiekty.\nW przeciwnym razie w trakcie importu może wystąpić błąd.\nCzy chcesz kontynuować? Przeliczanie id" \
                   " w zależności od komputera może potrwać kilka a nawet kilkanaście minut."

        reply = self.show_decision_msg_box('Przelicz ID', hint_msg)

        if reply == False:
            return

        layer_names = ["a_pnsw_pow", "a_oddz_pol", "a_wydz_pol", "a_uzyt_pol", "a_dzew_pol", "a_les_pol"]
        available_layers = {name: QgsProject.instance().mapLayersByName(name)[0] for name in layer_names if
                            QgsProject.instance().mapLayersByName(name)}

        if not available_layers:
            QMessageBox.critical(self, "Błąd", "Nie znaleziono właściwych warstw w projekcie.")
            return


        dialog = QDialog(self)
        dialog.setWindowTitle("Wybierz warstwy")
        layout = QVBoxLayout()

        checkboxes = {}
        for layer_name, layer in available_layers.items():
            checkbox = QCheckBox(layer_name)
            checkbox.setChecked(False)
            checkboxes[layer_name] = checkbox
            layout.addWidget(checkbox)

        ok_button = QPushButton("OK")
        layout.addWidget(ok_button)
        dialog.setLayout(layout)

        def accept_selection():
            dialog.accept()

        ok_button.clicked.connect(accept_selection)
        dialog.exec_()

        selected_layers = [available_layers[name] for name, checkbox in checkboxes.items() if checkbox.isChecked()]

        if not selected_layers:
            QMessageBox.warning(self, "Nie wskazano warstw", "Nie wskazano warstw do aktualizacji.")
            return

        expr = QgsExpression("$id + 1")

        for layer in selected_layers:
            if "id" not in [field.name() for field in layer.fields()]:
                QMessageBox.critical(self, "Błąd", f"Warstwa '{layer.name()}' nie zawiera pola 'id'.")
                return

            layer.startEditing()

            feature_count = layer.featureCount()
            if feature_count == 0:
                QgsMessageLog.logMessage(f"Layer {layer.name()} is empty.", "RecalculateID", Qgis.Warning)
                continue

            # Initialize progress bar
            progress = QProgressDialog(f"Aktualizacja warstwy {layer.name()}...", "Przerwij", 0, feature_count, self)
            progress.setWindowTitle("Postęp")
            progress.setModal(True)
            progress.show()

            context = QgsExpressionContext()
            context.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(layer))

            updated_count = 0
            for feature in layer.getFeatures(QgsFeatureRequest()):
                if progress.wasCanceled():
                    QMessageBox.warning(self, "Anulowano operację", "Operacja została wstrzymana przez użytkownika.")
                    layer.rollBack()
                    return

                context.setFeature(feature)
                new_id = expr.evaluate(context)
                layer.changeAttributeValue(feature.id(), layer.fields().lookupField("id"), new_id)

                updated_count += 1
                progress.setValue(updated_count)  # Update progress bar

            # Commit changes
            layer.commitChanges()
            QgsMessageLog.logMessage(
                f"Updated 'id' field in {layer.name()} ({updated_count}/{feature_count} features).", "RecalculateID",
                Qgis.Info)

        QMessageBox.information(self, "Sukces", "Przeliczono id dla wskazanych warstw.")



    ###Plugin init functions

    # at plugin start checks if there is any project with unsaved changes open.
    # if yes it will bring up a dialog and ask user if he wants to save project
    # if yes proceeds to save_project
    # if no continues to project_creation_wizard
    def check_if_project_open(self):
        if QgsProject.instance().isDirty():
            msg_box = QtWidgets.QMessageBox()
            msg_box.setWindowTitle("Wykryto niezapisane zmiany")
            msg_box.setText("Wykryto nie zapisane zmiany, czy chcesz zapisać obecny projekt? Nie zapisanie projektu może skutkować utratą danych.")

            tak_zapisz_button = msg_box.addButton("Tak zapisz", QtWidgets.QMessageBox.AcceptRole)
            nie_zapisuj_button = msg_box.addButton("Nie zapisuj", QtWidgets.QMessageBox.RejectRole)
            msg_box.setDefaultButton(nie_zapisuj_button)
            msg_box.exec()

            if msg_box.clickedButton() == tak_zapisz_button:
                return self.save_project(QgsProject.instance())
            else:
                return self.project_creation_wizard()
        elif not QgsProject.instance().fileName():
            return self.project_creation_wizard()
        return True

    def save_project(self, project):
        if project.fileName():
            project.write()
            QgsMessageLog.logMessage(f"Project saved at: {project.fileName()}", "LMN2QGIS", Qgis.Info)
            return True
        else:
            options = QtWidgets.QFileDialog.Options()

            # Prompt user to select a file to save the project

            file_name, _ = QtWidgets.QFileDialog.getSaveFileName(
                None,
                "Save Project",
                "",
                "QGIS Project Files (*.qgz *.qgs);;All Files (*)",
                options=options
            )

            if file_name:  # If the user selected a file
                project.write(file_name)  # Save the project to the selected file
                QgsMessageLog.logMessage(f"Project saved at: {file_name}", "LMN2QGIS", Qgis.Info)
                return True

            else:
                self.check_if_project_open()

### Project builder functions

    def create_working_directory(self):

        QgsMessageLog.logMessage(f"def project_creation_wizard - user designates new working directory", "LMN2QGIS", Qgis.Info)
        self.show_popup("Nie odnaleziono katalogu roboczego", r"Wskaż katalog, w którym przechowywane będą projekty. Zaleca się aby katalog znajdował się na profilu użytkowniku np. 'C:\Użytkownicy\nazwa.użytkownika\Dokumenty\AktualizacjaLMN'")

        QgsMessageLog.logMessage("User prompted to create/select working directory", "LMN2QGIS", Qgis.Info)

        working_directory = QFileDialog.getExistingDirectory(
            None,
            "Wybierz lub utwórz katalog roboczy",
            os.path.expanduser("~"),
            QFileDialog.ShowDirsOnly | QFileDialog.DontUseNativeDialog
        )

        if not working_directory:
            QgsMessageLog.logMessage("User canceled directory selection.", "LMN2QGIS", Qgis.Warning)
            return False

        # Ensure directory exists (in case user typed a name manually)
        try:
            if not os.path.exists(working_directory):
                os.makedirs(working_directory)

            self.storage_directory = os.path.join(working_directory, "000_Exporty_z_SILP")
            os.makedirs(self.storage_directory, exist_ok=True)

            for subdir in ["001_UNL", "002_SLMN", "003_POCH", "004_KontroleSLMN", "005_ObiektySzkicownika"]:
                os.makedirs(os.path.join(self.storage_directory, subdir), exist_ok=True)

            QMessageBox.information(None, "Sukces", f"Katalog roboczy '{working_directory}' został utworzony lub wybrany.")
            return working_directory

        except OSError as e:
            QgsMessageLog.logMessage(f"Error creating directory: {e}", "LMN2QGIS", Qgis.Critical)
            QMessageBox.critical(None, "Błąd", f"Nie udało się utworzyć katalogu: {e}")
            return False

    def create_project(self, working_directory):

        current_date = datetime.now().strftime("%d-%m-%Y")
        max_attempts = 10

        for attempt in range(max_attempts):
            unique_id = str(uuid.uuid4())[:4]
            project_directory = os.path.join(working_directory, f"Aktualizacja_{current_date}_{unique_id}")

            if not os.path.exists(project_directory):
                try:
                    os.makedirs(project_directory)
                    break
                except OSError as e:
                    QgsMessageLog.logMessage(f"Błąd tworzenia katalogu: {e}", "LMN2QGIS", Qgis.Critical)
                    QMessageBox.critical(
                        self.iface.mainWindow(),
                        "Błąd",
                        "Nie udało się utworzyć katalogu projektu."
                    )
                    return False
        else:
            QMessageBox.critical(
                self.iface.mainWindow(),
                "Błąd",
                "Nie udało się wygenerować unikatowej nazwy projektu."
            )
            return False

        config_directory = os.path.join(os.path.dirname(__file__), "config")
        source_file = os.path.join(config_directory, "Aktualizacja.qgz")
        project_name = f"Aktualizacja_{current_date}_{unique_id}.qgz"
        project_path = os.path.join(project_directory, project_name)

        try:
            shutil.copy(source_file, project_path)
        except FileNotFoundError:
            QgsMessageLog.logMessage("Plik szablonu nie znaleziony w katalogu konfiguracyjnym.", "LMN2QGIS", Qgis.Critical)
            QMessageBox.critical(
                self.iface.mainWindow(),
                "Błąd",
                "Plik szablonu projektu nie został znaleziony. Sprawdź konfigurację wtyczki."
            )
            return False
        except Exception as e:
            QgsMessageLog.logMessage(f"Błąd kopiowania pliku: {e}", "LMN2QGIS", Qgis.Critical)
            return False

        subdirectories = ["001_UNL", "002_SLMN", "003_POCH", "004_KontroleSLMN", "005_ObiektySzkicownika"]
        for subdir in subdirectories:
            try:
                os.makedirs(os.path.join(project_directory, subdir), exist_ok=True)
            except OSError as e:
                QgsMessageLog.logMessage(f"Błąd tworzenia podkatalogu {subdir}: {e}", "LMN2QGIS", Qgis.Critical)
                return False

        QgsMessageLog.logMessage(f"Utworzono nowy projekt: {project_directory}", "LMN2QGIS", Qgis.Info)
        self.open_project(project_path, project_directory)
        return True

    def select_project(self, working_directory):

        project_path, _ = QFileDialog.getOpenFileName(
            self.iface.mainWindow(),
            "Wybierz istniejący projekt",
            working_directory,
            "QGIS Projects (*.qgz)"
        )

        if project_path:
            project_directory = os.path.dirname(project_path)
            self.open_project(project_path, None)
            return True

        return False

    def open_project(self, project_path, project_directory):

        if os.path.exists(project_path):
            #self.iface.addProject(project_path)
            QgsProject.instance().read(project_path)
            if project_directory:
                os.startfile(project_directory)  # Opens directory in file explorer
            QgsMessageLog.logMessage(f"Otworzono projekt: {project_path}", "LMN2QGIS", Qgis.Info)
        else:
            QMessageBox.critical(
                self.iface.mainWindow(),
                "Błąd",
                "Nie udało się otworzyć projektu. Plik nie istnieje."
            )

    def project_creation_wizard(self):
        config_directory = os.path.join(os.path.dirname(__file__), "config")
        config_file = os.path.join(config_directory, "workingDirectory.txt")

        if not os.path.exists(config_file):
            QgsMessageLog.logMessage("Brak pliku konfiguracji, tworzenie workingDirectory.txt", "LMN2QGIS", Qgis.Info)
            with open(config_file,'w') as f:
                f.write("")

        with open(config_file, 'r') as f:
            working_directory = f.read().strip() or None

        if not working_directory or not os.path.exists(working_directory):
            working_directory = self.create_working_directory()
            if not working_directory:
                return False
            with open(config_file, 'w') as f:
                f.write(working_directory)

        projects = [d for d in os.listdir(working_directory) if os.path.isdir(os.path.join(working_directory, d)) and d.startswith("Aktualizacja_")]
        if projects:
            if self.show_decision_msg_box("Kreator projektów", "Czy chcesz stworzyć nowy projekt?"):
                return self.create_project(working_directory)
            elif self.show_decision_msg_box("Kreator projektów", "Czy chcesz otworzyć istniejący projekt?"):
                return self.select_project(working_directory)
            else:
                return False
        else:
            return self.create_project(working_directory)

    # Utilities

    def show_popup(self, title, message):
        QMessageBox.warning(self.iface.mainWindow(), title, message)

    def show_decision_msg_box(self, title, message, Yes_role = "Tak", No_role = "Nie"):
        msg_box = QMessageBox()
        msg_box.setWindowTitle(title)
        msg_box.setText(message)

        tak_button = msg_box.addButton(Yes_role, QMessageBox.AcceptRole)
        nie_button = msg_box.addButton(No_role, QMessageBox.RejectRole)

        msg_box.exec()

        if msg_box.clickedButton() == tak_button:
            return True
        else:
            return False


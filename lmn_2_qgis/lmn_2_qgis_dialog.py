# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Lmn2QgisDialog
                                 A QGIS plugin
 Plugin allows for automatic project build needed for updating Forest Numerical Map and data management
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-11-26
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Adam Kurzawiński
        email                : adam.kurzawinski@katowice.lasy.gov.pl
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/

"""

import os
import subprocess
import shutil
import csv
import sys
import uuid
import zipfile
from os.path import basename
from qgis.core import (Qgis, QgsProject, QgsLayerTreeGroup, QgsVectorLayer, QgsRasterLayer,
    QgsCoordinateReferenceSystem, QgsSettings, QgsUnitTypes, QgsLayerTreeLayer, QgsMessageLog, QgsExpression, QgsExpressionContext, QgsExpressionContextUtils, QgsFeatureRequest, )
from PyQt5.QtCore import QUrl
from PyQt5.QtGui import QColor
from qgis.PyQt import uic
from qgis.PyQt import QtWidgets, QtGui
from PyQt5.QtWidgets import QFileDialog, QLineEdit, QMessageBox, QPushButton, QDialog, QVBoxLayout, QCheckBox, QProgressDialog, QInputDialog
from datetime import datetime

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'lmn_2_qgis_dialog_base.ui'))

class Lmn2QgisDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, iface, parent=None):
        """Constructor."""
        super(Lmn2QgisDialog, self).__init__(parent)

        self.iface = iface

        self.setupUi(self)

        # Set the window icon
        self.setWindowIcon(QtGui.QIcon(":/plugins/lmn_2_qgis/icon.png"))

        # dialog elemets connections to functions
        self.pbCancel.clicked.connect(self.on_pbButton_clicked)
        self.pbClear.clicked.connect(self.on_pbButton_clicked)
        self.pbBrowseUNL.clicked.connect(self.on_pbButton_clicked)
        self.pbBrowseSLMN.clicked.connect(self.on_pbButton_clicked)
        self.pbBrowsePOCH.clicked.connect(self.on_pbButton_clicked)
        self.pbBrowseKSLMN.clicked.connect(self.on_pbButton_clicked)
        self.pbLoad.clicked.connect(self.on_pbButton_clicked)
        self.pbExport.clicked.disconnect()
        self.pbExport.clicked.connect(self.on_pbExport_clicked)
        self.pbRecalcId.clicked.disconnect()
        self.pbRecalcId.clicked.connect(self.on_pbRecalcId_clicked)

###main dialog functions group

    def initGui(self):
        self.action = QtWidgets.QAction("Open Dialog", self.iface.mainWindow())
        self.action.triggered.connect(self.showDialog)
        self.iface.addPluginToMenu("&My Plugin", self.action)

    def showDialog(self):
        self.dialog = Lmn2QgisDialog(self.iface)
        self.dialog.show()

    def on_pbButton_clicked(self):
        sender = self.sender()
        button_name = sender.objectName()
        caption = None
        lineEdit = None

        match button_name:
            case 'pbCancel':
                self.leUNL.clear()
                self.leSLMN.clear()
                self.lePOCH.clear()
                self.leKSLMN.clear()
                self.close()

            case 'pbClear':
                self.leUNL.clear()
                self.leSLMN.clear()
                self.lePOCH.clear()
                self.leKSLMN.clear()

            case 'pbLoad':
                self.loadData()

            case 'pbBrowseUNL':
                caption = "Wskaż plik bazy UNL"
                lineEdit = self.leUNL
            case 'pbBrowseSLMN':
                caption = "Wskaż plik bazy SLMN"
                lineEdit = self.leSLMN
            case 'pbBrowsePOCH':
                caption = "Wskaż plik bazy POCH"
                lineEdit = self.lePOCH
            case 'pbBrowseKSLMN':
                caption = "Wskaż plik bazy KSLMN"
                lineEdit = self.leKSLMN

        if caption is not None and lineEdit is not None:
            directory = self.browseFiles(True, "ZIP Files (*.zip)", caption)
            lineEdit.setText(directory)


### utility functions group

    # utility to quickly open desired directory either on Win, Mac or Linux

    def open_folder(self, folder_path):
        # Normalize the folder path and make sure it is absolute
        folder_path = os.path.abspath(folder_path)

        try:
            if sys.platform.startswith('win'):  # Windows
                subprocess.Popen(f'explorer "{folder_path}"')
            elif sys.platform == 'darwin':  # MacOS
                subprocess.Popen(['open', folder_path])
            else:  # Linux or other
                subprocess.Popen(['xdg-open', folder_path])
        except Exception as e:
            # Log the error or display a message
            QgsMessageLog.logMessage(f"def open_folder - Error opening folder: {e}", "LMN2QGIS", Qgis.Critical)

    # opens browse windows, for files == true browses files, for files == false browses directories
    def browseFiles(self, files=False, file_types=None, browseCaption=None, default_directory = os.path.dirname(__file__)):
        options = QtWidgets.QFileDialog.Options()

        if files:
            file, _ = QFileDialog.getOpenFileName(
                parent=self,
                caption=browseCaption,
                directory=default_directory,
                filter=file_types,
                options=options
            )
            return file
        else:
            directory = QFileDialog.getExistingDirectory(
                parent=self,
                caption=browseCaption,
                directory=os.path.dirname(__file__),
                options=options
            )
            return directory

    def unload(self):
        if hasattr(self, 'dialog') and self.dialog:
            self.dialog.close()
            self.dialog = None

    # utility for unzipping files
    # args:
    # file : provide fileName with full directory
    # dir  : provide directory where file should be unzipped
    # def unzip_file(self, file, dir):
    #    with ZipFile(file, 'r') as zip:
    #       zip.extractall(dir)

    def unzip_file(self, zip_file_path, target_directory, folder_key):

        if folder_key == 'UNL':

            unl_target_directory = target_directory + '/unl'
            if zipfile.is_zipfile(zip_file_path):
                try:
                    # Open the zip file
                    with zipfile.ZipFile(zip_file_path, 'r') as zip_ref:
                        # Extract all the contents into the target directory
                        zip_ref.extractall(unl_target_directory)
                        for file_name in os.listdir(unl_target_directory):
                            subdir1 = os.path.join(unl_target_directory, file_name)
                            if os.path.isdir(subdir1):
                                # Check if 'unl' exists inside the subdir1
                                unl_path = os.path.join(subdir1, 'unl')
                                if os.path.isdir(unl_path):
                                    # Move files from 'unl' folder to target_directory
                                    for each_file in os.listdir(unl_path):
                                        source_file = os.path.join(unl_path, each_file)
                                        target_file = os.path.join(target_directory, each_file)
                                        if os.path.isfile(source_file):
                                            shutil.move(source_file, target_file)
                                            QgsMessageLog.logMessage(f"def unzip_file - Moved: {source_file} → {target_file}",
                                                                     "LMN2QGIS", Qgis.Info)
                                    shutil.rmtree(unl_target_directory)

                        QgsMessageLog.logMessage(f"def unzip_file - Successfully extracted {zip_file_path} to {target_directory}", "LMN2QGIS", Qgis.Info)
                except Exception as e:
                    QgsMessageLog.logMessage(f"def unzip_file - Error unzipping the file {zip_file_path}: {e}",
                                             "LMN2QGIS", Qgis.Critical)
            else:
                QgsMessageLog.logMessage(f"def unzip_file - '{zip_file_path}' is not a valid zip file.", "LMN2QGIS", Qgis.Critical)

        else:
            if zipfile.is_zipfile(zip_file_path):
                try:
                    # Open the zip file
                    with zipfile.ZipFile(zip_file_path, 'r') as zip_ref:
                        # Extract all the contents into the target directory
                        zip_ref.extractall(target_directory)
                        QgsMessageLog.logMessage(f"Successfully extracted {zip_file_path} to {target_directory}",
                                                 "LMN2QGIS", Qgis.Info)
                except Exception as e:
                    QgsMessageLog.logMessage(f"Error unzipping the file {zip_file_path}: {e}", "LMN2QGIS",
                                             Qgis.Critical)
            else:
                QgsMessageLog.logMessage(f"{zip_file_path} is not a valid zip file.", "LMN2QGIS",
                                         Qgis.Critical)

    def loadData(self):
        current_project = QgsProject.instance().fileName()
        project_dir = os.path.dirname(current_project)

        # Save currently opened project if one is open
        if current_project:
            QgsProject.instance().write()

        # Clear the current project
        QgsProject.instance().clear()

        # Data paths from QLineEdits
        dataPaths = {
            'UNL': self.leUNL.text(),
            'SLMN': self.leSLMN.text(),
            'POCH': self.lePOCH.text(),
            'KSLMN': self.leKSLMN.text()
        }

        unzip_directories = {
            'UNL': os.path.join('001_UNL','unl'),
            'SLMN': '002_SLMN',
            'POCH': '003_POCH',
            'KSLMN': '004_KontroleSLMN'
        }

        # Unzip files into their respective directories
        for key, path in dataPaths.items():
            if path:  # Only process non-empty paths
                # Join the project directory with the sub-directory name
                directory = os.path.join(project_dir, unzip_directories.get(key))
                if directory:
                    try:
                        # Ensure dir exists
                        if not os.path.exists(directory):
                            os.makedirs(directory)
                        QgsMessageLog.logMessage(f"Unzipping {path} into {directory}",
                                                 "LMN2QGIS", Qgis.Info)
                        self.unzip_file(path, directory, key)  # Pass the key to handle special UNL case
                    except Exception as e:
                        QgsMessageLog.logMessage(f"Error unzipping {path}: {e}",
                                                 "LMN2QGIS", Qgis.Critical)

        # Reload the project if it was previously open
        if current_project:
            project_instance = QgsProject.instance()
            if not project_instance.read(current_project):
                QgsMessageLog.logMessage("Failed to reload the project file.","LMN2QGIS", Qgis.Critical)
            else:
                QgsMessageLog.logMessage("Project reloaded successfully.", "LMN2QGIS", Qgis.Info)

    def on_pbExport_clicked(self):
        # Log the start of the function
        QgsMessageLog.logMessage("on_pbExport_clicked - Start", "LMN2QGIS", Qgis.Info)

        # Get the current project directory
        project_directory = os.path.dirname(QgsProject.instance().fileName())

        # Define paths relative to the project directory
        data_to_export_directory = os.path.join(project_directory, "002_SLMN")
        QgsMessageLog.logMessage(
            f"on_pbExport_clicked - directory where files to export are stored is: {data_to_export_directory}",
            "LMN2QGIS", Qgis.Info)

        export_directory = os.path.join(project_directory, '000_DoImportuSILP')
        QgsMessageLog.logMessage(
            f"on_pbExport_clicked - directory where files will be exported as zip: {export_directory}", "LMN2QGIS",
            Qgis.Info)

        # Ensure "000_DoImportuSILP" folder exists, create it if not
        if not os.path.isdir(export_directory):
            os.makedirs(export_directory)

        # Check if "002_SLMN" folder exists
        if not os.path.isdir(data_to_export_directory):
            self.show_popup('Błąd', 'Folder 002_SLMN nie istnieje!')
            return  # Stop the function if folder doesn't exist

        # Check if "002_SLMN" folder is empty
        elif len(os.listdir(data_to_export_directory)) == 0:
            self.show_popup('Błąd', 'Folder 002_SLMN jest pusty!')
            return  # Stop the function if folder is empty

        # Get the current time for the zip file naming
        time_tag = datetime.now()
        export_filename = time_tag.strftime("%Y%m%d_%H.%M.%S.zip")

        # Create a zip file containing all files in the "002_SLMN" folder
        zip_file_path = os.path.join(export_directory, export_filename)

        # Log before creating the zip file
        QgsMessageLog.logMessage(f"on_pbExport_clicked - Creating zip file at: {zip_file_path}", "LMN2QGIS", Qgis.Info)

        if not os.path.exists(zip_file_path):  # Check if the file already exists
            with zipfile.ZipFile(zip_file_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
                for root, dirs, files in os.walk(data_to_export_directory):
                    for file in files:
                        # Generate the full path of the file and its relative path for zip
                        file_path = os.path.join(root, file)
                        arcname = os.path.relpath(file_path, data_to_export_directory)

                        # Log each file being added
                        QgsMessageLog.logMessage(f"Adding file to zip: {arcname}", "LMN2QGIS", Qgis.Info)

                        # Write the file to the zip (flatten the directory structure if desired)
                        zipf.write(file_path, arcname)

            QgsMessageLog.logMessage(f"on_pbExport_clicked - Zip file created: {zip_file_path}", "LMN2QGIS", Qgis.Info)
        else:
            QgsMessageLog.logMessage(f"on_pbExport_clicked - Zip file already exists: {zip_file_path}", "LMN2QGIS",
                                     Qgis.Info)

        # Open the folder (cross-platform way to open the folder)
        if os.name == 'nt':  # Windows
            subprocess.call(('cmd', '/c', 'start', '', export_directory))
        elif os.name == 'posix':  # macOS / Linux
            subprocess.call(('open', export_directory)) if sys.platform == 'darwin' else subprocess.call(
                ('xdg-open', export_directory))

        # Log the end of the function
        QgsMessageLog.logMessage("on_pbExport_clicked - End", "LMN2QGIS", Qgis.Info)



    def on_pbRecalcId_clicked(self):
        # Step 1: Show initial hint
        hint_msg = "This function will update the 'id' field by applying '$id + 1'.\nDo you want to continue?"
        reply = QMessageBox.question(self, 'Recalculate ID', hint_msg, QMessageBox.Yes | QMessageBox.No, QMessageBox.No)

        if reply == QMessageBox.No:
            return

        # Step 2: Get the target layers
        layer_names = ["a_pnsw_pow", "a_oddz_pol", "a_wydz_pol", "a_uzyt_pol", "a_dzew_pol", "a_les_pol"]
        available_layers = {name: QgsProject.instance().mapLayersByName(name)[0] for name in layer_names if
                            QgsProject.instance().mapLayersByName(name)}

        if not available_layers:
            QMessageBox.critical(self, "Error", "No matching layers found in the project.")
            return

        # Step 3: Display checkboxes for layer selection
        dialog = QDialog(self)
        dialog.setWindowTitle("Select Layers to Update")
        layout = QVBoxLayout()

        checkboxes = {}
        for layer_name, layer in available_layers.items():
            checkbox = QCheckBox(layer_name)
            checkbox.setChecked(True)
            checkboxes[layer_name] = checkbox
            layout.addWidget(checkbox)

        ok_button = QPushButton("OK")
        layout.addWidget(ok_button)
        dialog.setLayout(layout)

        def accept_selection():
            dialog.accept()

        ok_button.clicked.connect(accept_selection)
        dialog.exec_()

        # Step 4: Apply the expression to selected layers with progress tracking
        selected_layers = [available_layers[name] for name, checkbox in checkboxes.items() if checkbox.isChecked()]

        if not selected_layers:
            QMessageBox.warning(self, "No Layers Selected", "No layers were selected for updating.")
            return

        expr = QgsExpression("$id + 1")

        for layer in selected_layers:
            if "id" not in [field.name() for field in layer.fields()]:
                QMessageBox.critical(self, "Error", f"Layer '{layer.name()}' does not contain an 'id' field.")
                return

            # Start editing the layer
            layer.startEditing()

            # Get feature count
            feature_count = layer.featureCount()
            if feature_count == 0:
                QgsMessageLog.logMessage(f"Layer {layer.name()} is empty.", "RecalculateID", Qgis.Warning)
                continue

            # Initialize progress bar
            progress = QProgressDialog(f"Updating {layer.name()}...", "Cancel", 0, feature_count, self)
            progress.setWindowTitle("Progress")
            progress.setModal(True)
            progress.show()

            context = QgsExpressionContext()
            context.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(layer))

            updated_count = 0
            for feature in layer.getFeatures(QgsFeatureRequest()):
                if progress.wasCanceled():
                    QMessageBox.warning(self, "Cancelled", "Operation was cancelled by the user.")
                    layer.rollBack()
                    return

                context.setFeature(feature)
                new_id = expr.evaluate(context)
                layer.changeAttributeValue(feature.id(), layer.fields().lookupField("id"), new_id)

                updated_count += 1
                progress.setValue(updated_count)  # Update progress bar

            # Commit changes
            layer.commitChanges()
            QgsMessageLog.logMessage(
                f"Updated 'id' field in {layer.name()} ({updated_count}/{feature_count} features).", "RecalculateID",
                Qgis.Info)

        QMessageBox.information(self, "Success", "ID field has been updated for selected layers.")



    ###Plugin init functions

    # at plugin start checks if there is any project with unsaved changes open.
    # if yes it will bring up a dialog and ask user if he wants to save project
    # if yes proceeds to save_project
    # if no continues to project_creation_wizard
    def check_if_project_open(self):
        if QgsProject.instance().isDirty():
            msg_box = QtWidgets.QMessageBox()
            msg_box.setWindowTitle("Wykryto niezapisane zmiany")
            msg_box.setText("Wykryto nie zapisane zmiany, czy chcesz zapisać obecny projekt? Nie zapisanie projektu może skutkować utratą danych.")

            tak_zapisz_button = msg_box.addButton("Tak zapisz", QtWidgets.QMessageBox.AcceptRole)
            nie_zapisuj_button = msg_box.addButton("Nie zapisuj", QtWidgets.QMessageBox.RejectRole)
            msg_box.setDefaultButton(nie_zapisuj_button)
            msg_box.exec()

            if msg_box.clickedButton() == tak_zapisz_button:
                return self.save_project(QgsProject.instance())
            else:
                return self.project_creation_wizard()
        elif not QgsProject.instance().fileName():
            return self.project_creation_wizard()
        return True

    def save_project(self, project):
        if project.fileName():
            project.write()
            QgsMessageLog.logMessage(f"Project saved at: {project.fileName()}", "LMN2QGIS", Qgis.Info)
            return True
        else:
            options = QtWidgets.QFileDialog.Options()

            # Prompt user to select a file to save the project

            file_name, _ = QtWidgets.QFileDialog.getSaveFileName(
                None,
                "Save Project",
                "",
                "QGIS Project Files (*.qgz *.qgs);;All Files (*)",
                options=options
            )

            if file_name:  # If the user selected a file
                project.write(file_name)  # Save the project to the selected file
                QgsMessageLog.logMessage(f"Project saved at: {file_name}", "LMN2QGIS", Qgis.Info)
                return True

            else:
                self.check_if_project_open()

### Project builder functions

    def create_working_directory(self):
        QgsMessageLog.logMessage(f"def project_creation_wizard - user designates new working directory", "LMN2QGIS", Qgis.Info)
        self.show_popup("Nie odnaleziono katalogu roboczego", r"Wskaż katalog, w którym przechowywane będą projekty. Zaleca się aby katalog znajdował się na profilu użytkowniku np. 'C:\Użytkownicy\nazwa.użytkownika\Dokumenty\AktualizacjaLMN'")
        working_directory = self.browseFiles(False, None, "Wskaż katalog roboczy")

        if not working_directory:
            QgsMessageLog.logMessage("Użytkownik anulował wybór katalogu roboczego.", "LMN2QGIS", Qgis.Warning)
            return False

        folder_name, ok = QInputDialog.getText(None, "AktualizacjaLMN", "Podaj nazwę katalogu roboczego, w którym przechowywane będą projekty oraz dane SILP")
        if ok and folder_name.strip():
            working_directory = os.path.join(working_directory, folder_name.strip())
            if not os.path.exists(working_directory):
                try:
                    os.makedirs(working_directory)
                    QMessageBox.information(None, "Sukces", f"Folder '{folder_name}' został utworzony.")
                    return working_directory
                except OSError as e:
                    QgsMessageLog.logMessage(f"Błąd tworzenia katalogu: {e}", "LMN2QGIS", Qgis.Critical)
                    return False
            else:
                QMessageBox.warning(None, "Błąd", f"Folder '{folder_name}' już istnieje.")
                return working_directory
        else:
            QMessageBox.warning(None, "Błąd", "Nie podano nazwy folderu.")
            return False

    def create_project(self, working_directory):
        """Creates a new project directory with a unique name and copies the QGIS template file."""
        current_date = datetime.now().strftime("%d-%m-%Y")
        max_attempts = 10

        for attempt in range(max_attempts):
            unique_id = str(uuid.uuid4())[:4]
            project_directory = os.path.join(working_directory, f"Aktualizacja_{current_date}_{unique_id}")

            if not os.path.exists(project_directory):
                try:
                    os.makedirs(project_directory, exist_ok=True)
                    break
                except OSError as e:
                    QgsMessageLog.logMessage(f"Błąd tworzenia katalogu: {e}", "LMN2QGIS", Qgis.Critical)
                    QMessageBox.critical(
                        self.iface.mainWindow(),
                        "Błąd",
                        "Nie udało się utworzyć katalogu projektu."
                    )
                    return False
        else:
            QMessageBox.critical(
                self.iface.mainWindow(),
                "Błąd",
                "Nie udało się wygenerować unikatowej nazwy projektu."
            )
            return False

        config_directory = os.path.join(os.path.dirname(__file__), "config")
        source_file = os.path.join(config_directory, "Aktualizacja.qgz")
        project_name = f"Aktualizacja_{current_date}_{unique_id}.qgz"
        project_path = os.path.join(project_directory, project_name)

        try:
            shutil.copy(source_file, project_path)
        except FileNotFoundError:
            QgsMessageLog.logMessage("Plik szablonu nie znaleziony w katalogu konfiguracyjnym.", "LMN2QGIS", Qgis.Critical)
            QMessageBox.critical(
                self.iface.mainWindow(),
                "Błąd",
                "Plik szablonu projektu nie został znaleziony. Sprawdź konfigurację wtyczki."
            )
            return False
        except Exception as e:
            QgsMessageLog.logMessage(f"Błąd kopiowania pliku: {e}", "LMN2QGIS", Qgis.Critical)
            return False

        subdirectories = ["001_UNL", "002_SLMN", "003_POCH", "004_KontroleSLMN"]
        for subdir in subdirectories:
            try:
                os.makedirs(os.path.join(project_directory, subdir), exist_ok=True)
            except OSError as e:
                QgsMessageLog.logMessage(f"Błąd tworzenia podkatalogu {subdir}: {e}", "LMN2QGIS", Qgis.Critical)
                return False

        QgsMessageLog.logMessage(f"Utworzono nowy projekt: {project_directory}", "LMN2QGIS", Qgis.Info)
        self.open_project(project_path, project_directory)
        return True

    def select_project(self, working_directory):
        """Prompts user to select an existing QGIS project file and opens it."""

        project_path, _ = QFileDialog.getOpenFileName(
            self.iface.mainWindow(),
            "Wybierz istniejący projekt",
            working_directory,
            "QGIS Projects (*.qgz)"
        )

        if project_path:
            project_directory = os.path.dirname(project_path)
            self.open_project(project_path, None)
            return True

        return False

    def open_project(self, project_path, project_directory):
        """Opens the selected QGIS project and the corresponding directory."""
        if os.path.exists(project_path):
            self.iface.addProject(project_path)
            if project_directory:
                os.startfile(project_directory)  # Opens directory in file explorer
            QgsMessageLog.logMessage(f"Otworzono projekt: {project_path}", "LMN2QGIS", Qgis.Info)
        else:
            QMessageBox.critical(
                self.iface.mainWindow(),
                "Błąd",
                "Nie udało się otworzyć projektu. Plik nie istnieje."
            )

    def project_creation_wizard(self):
        config_directory = os.path.join(os.path.dirname(__file__), "config")
        config_file = os.path.join(config_directory, "workingDirectory.txt")

        if not os.path.exists(config_file):
            QgsMessageLog.logMessage("Brak pliku konfiguracji, tworzenie workingDirectory.txt", "LMN2QGIS", Qgis.Info)
            with open(config_file,'w') as f:
                f.write("")

        with open(config_file, 'r') as f:
            working_directory = f.read().strip()

        if not working_directory or not os.path.exists(working_directory):
            working_directory = self.create_working_directory()
            if not working_directory:
                return False
            with open(config_file, 'w') as f:
                f.write(working_directory)

        projects = [d for d in os.listdir(working_directory) if os.path.isdir(os.path.join(working_directory, d)) and d.startswith("Aktualizacja_")]
        if projects:
            if self.show_decision_msg_box("Kreator projektów", "Czy chcesz stworzyć nowy projekt?"):
                return self.create_project(working_directory)
            elif self.show_decision_msg_box("Kreator projektów", "Czy chcesz otworzyć istniejący projekt?"):
                return self.select_project(working_directory)
            else:
                return False
        else:
            return self.create_project(working_directory)

    # Utilities

    def show_popup(self, title, message):
        QMessageBox.warning(self, title, message)

    def show_decision_msg_box(self, title, message):
        msg_box = QMessageBox()
        msg_box.setWindowTitle(title)
        msg_box.setText(message)

        tak_button = msg_box.addButton("Tak", QMessageBox.AcceptRole)
        nie_button = msg_box.addButton("Nie", QMessageBox.RejectRole)

        msg_box.exec()

        if msg_box.clickedButton() == tak_button:
            return True
        else:
            return False

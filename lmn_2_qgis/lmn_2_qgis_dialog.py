# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Lmn2QgisDialog
                                 A QGIS plugin
 Plugin allows for automatic project build needed for updating Forest Numerical Map and data management
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-11-26
        git sha              : $Format:%H$
        copyright            : (C) 2024 by Adam Kurzawiński
        email                : adam.kurzawinski@katowice.lasy.gov.pl
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/

"""

import os
import subprocess
import shutil
import csv
import sys
import uuid
import zipfile
from os.path import basename
from qgis.core import (Qgis, QgsProject, QgsLayerTreeGroup, QgsVectorLayer, QgsRasterLayer,
    QgsCoordinateReferenceSystem, QgsSettings, QgsUnitTypes, QgsLayerTreeLayer, QgsMessageLog, QgsExpression, QgsExpressionContext, QgsExpressionContextUtils, QgsFeatureRequest, )
from PyQt5.QtCore import QUrl
from PyQt5.QtGui import QColor
from qgis.PyQt import uic
from qgis.PyQt import QtWidgets, QtGui
from PyQt5.QtWidgets import QFileDialog, QLineEdit, QMessageBox, QPushButton, QDialog, QVBoxLayout, QCheckBox, QProgressDialog, QInputDialog
from datetime import datetime

# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'lmn_2_qgis_dialog_base.ui'))

class Lmn2QgisDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, iface, parent=None):
        """Constructor."""
        super(Lmn2QgisDialog, self).__init__(parent)

        self.iface = iface

        self.setupUi(self)

        # Set the window icon
        self.setWindowIcon(QtGui.QIcon(":/plugins/lmn_2_qgis/icon.png"))

        # Default working directory
        self.storage_directory = None

        # dialog elemets connections to functions
        self.pbCancel.clicked.connect(self.on_pbButton_clicked)
        self.pbClear.clicked.connect(self.on_pbButton_clicked)
        self.pbBrowseUNL.clicked.connect(self.on_pbButton_clicked)
        self.pbBrowseSLMN.clicked.connect(self.on_pbButton_clicked)
        self.pbBrowsePOCH.clicked.connect(self.on_pbButton_clicked)
        self.pbBrowseKSLMN.clicked.connect(self.on_pbButton_clicked)
        self.pbBrowseSzkice.clicked.connect(self.on_pbButton_clicked)
        self.pbLoad.clicked.connect(self.on_pbButton_clicked)
        self.pbExport.clicked.disconnect()
        self.pbExport.clicked.connect(self.on_pbExport_clicked)
        self.pbRecalcId.clicked.disconnect()
        self.pbRecalcId.clicked.connect(self.on_pbRecalcId_clicked)

###main dialog functions group

    def initGui(self):
        self.action = QtWidgets.QAction("Open Dialog", self.iface.mainWindow())
        self.action.triggered.connect(self.showDialog)
        self.iface.addPluginToMenu("&My Plugin", self.action)

    def showDialog(self):
        self.dialog = Lmn2QgisDialog(self.iface)
        self.dialog.show()

    def on_pbButton_clicked(self):
        sender = self.sender()
        button_name = sender.objectName()
        caption = None
        lineEdit = None

        match button_name:
            case 'pbCancel':
                self.leUNL.clear()
                self.leSLMN.clear()
                self.lePOCH.clear()
                self.leKSLMN.clear()
                self.leSzkice.clear()
                self.close()

            case 'pbClear':
                self.leUNL.clear()
                self.leSLMN.clear()
                self.lePOCH.clear()
                self.leKSLMN.clear()
                self.leSzkice.clear()

            case 'pbLoad':
                self.loadData()

            case 'pbBrowseUNL':
                caption = "Wskaż plik zip bazy UNL"
                lineEdit = self.leUNL
            case 'pbBrowseSLMN':
                caption = "Wskaż plik zip danych w standardzie SLMN"
                lineEdit = self.leSLMN
            case 'pbBrowsePOCH':
                caption = "Wskaż plik zip z pochodnymi"
                lineEdit = self.lePOCH
            case 'pbBrowseKSLMN':
                caption = "Wskaż plik zip kontroli standardu LMN"
                lineEdit = self.leKSLMN
            case 'pbBrowseSzkice':
                caption = "Wskaż plik zip projektu mLas"
                lineEdit = self.leSzkice

        if caption is not None and lineEdit is not None:
            directory = self.browseFiles(True, "ZIP Files (*.zip)", caption, self.storage_directory)
            lineEdit.setText(directory)


### utility functions group

    # utility to quickly open desired directory either on Win, Mac or Linux - not tested on other OS than Windows!

    def open_folder(self, folder_path):
        folder_path = os.path.abspath(folder_path)

        try:
            if sys.platform.startswith('win'):  # Windows
                subprocess.Popen(f'explorer "{folder_path}"')
            elif sys.platform == 'darwin':  # MacOS
                subprocess.Popen(['open', folder_path])
            else:  # Linux or other
                subprocess.Popen(['xdg-open', folder_path])
        except Exception as e:
            QgsMessageLog.logMessage(f"def open_folder - Error opening folder: {e}", "LMN2QGIS", Qgis.Critical)

    # opens browse windows, for files == true browses files, for files == false browses directories
    def browseFiles(self, files=False, file_types=None, browseCaption=None, default_directory = os.path.dirname(__file__)):
        options = QtWidgets.QFileDialog.Options()

        if files:
            file, _ = QFileDialog.getOpenFileName(
                parent=self,
                caption=browseCaption,
                directory=default_directory,
                filter=file_types,
                options=options
            )
            return file
        else:
            directory = QFileDialog.getExistingDirectory(
                parent=self,
                caption=browseCaption,
                directory=os.path.dirname(__file__),
                options=options
            )
            return directory

    def unload(self):
        if hasattr(self, 'dialog') and self.dialog:
            self.dialog.close()
            self.dialog = None

    # utility for unzipping files
    # args:
    # file : provide fileName with full directory
    # dir  : provide directory where file should be unzipped
    # def unzip_file(self, file, dir):
    #    with ZipFile(file, 'r') as zip:
    #       zip.extractall(dir)

    def unzip_file(self, zip_file_path, target_directory, folder_key):

        if folder_key == 'UNL':

            unl_target_directory = os.path.join(target_directory,'unl')
            if zipfile.is_zipfile(zip_file_path):
                try:
                    with zipfile.ZipFile(zip_file_path, 'r') as zip_ref:
                        # Extract contents to the target directory
                        zip_ref.extractall(unl_target_directory)
                        for file_name in os.listdir(unl_target_directory):
                            subdir1 = os.path.join(unl_target_directory, file_name)
                            if os.path.isdir(subdir1):
                                # Check if 'unl' exists insubdir1
                                unl_path = os.path.join(subdir1, 'unl')
                                if os.path.isdir(unl_path):
                                    # Move files from 'unl' folder to target_directory
                                    for each_file in os.listdir(unl_path):
                                        source_file = os.path.join(unl_path, each_file)
                                        target_file = os.path.join(target_directory, each_file)
                                        if os.path.isfile(source_file):
                                            shutil.move(source_file, target_file)
                                            QgsMessageLog.logMessage(f"def unzip_file - Moved: {source_file} → {target_file}",
                                                                     "LMN2QGIS", Qgis.Info)
                                    shutil.rmtree(unl_target_directory)

                        QgsMessageLog.logMessage(f"def unzip_file - Successfully extracted {zip_file_path} to {target_directory}", "LMN2QGIS", Qgis.Info)
                except Exception as e:
                    QgsMessageLog.logMessage(f"def unzip_file - Error unzipping the file {zip_file_path}: {e}",
                                             "LMN2QGIS", Qgis.Critical)
            else:
                QgsMessageLog.logMessage(f"def unzip_file - '{zip_file_path}' is not a valid zip file.", "LMN2QGIS", Qgis.Critical)


        elif folder_key == 'mLAS':
            QgsMessageLog.logMessage(f"Processing mLAS extraction from {zip_file_path} to {target_directory}","LMN2QGIS", Qgis.Info)

            try:
                with zipfile.ZipFile(zip_file_path, 'r') as zip_ref:
                    found_files = [file for file in zip_ref.namelist() if os.path.basename(file).startswith("szkic_")]
                    if not found_files:
                        QgsMessageLog.logMessage("No szkic_ files found in the ZIP archive.", "LMN2QGIS", Qgis.Warning)
                        return

                    for file in found_files:
                        output_path = os.path.join(target_directory, os.path.basename(file))  # Flatten extraction
                        with zip_ref.open(file) as source, open(output_path, "wb") as dest:
                            dest.write(source.read())
                        QgsMessageLog.logMessage(f"Extracted szkic_ file: {file} → {output_path}", "LMN2QGIS", Qgis.Info)
            except Exception as e:
                QgsMessageLog.logMessage(f"Error extracting szkic_ files: {e}", "LMN2QGIS", Qgis.Critical)
        else:
            if zipfile.is_zipfile(zip_file_path):
                try:
                    with zipfile.ZipFile(zip_file_path, 'r') as zip_ref:
                        zip_ref.extractall(target_directory)
                        QgsMessageLog.logMessage(f"Successfully extracted {zip_file_path} to {target_directory}",
                                                 "LMN2QGIS", Qgis.Info)
                except Exception as e:
                    QgsMessageLog.logMessage(f"Error unzipping the file {zip_file_path}: {e}", "LMN2QGIS",
                                             Qgis.Critical)
            else:
                QgsMessageLog.logMessage(f"{zip_file_path} is not a valid zip file.", "LMN2QGIS",
                                         Qgis.Critical)

    def loadData(self):
        current_project = QgsProject.instance().fileName()
        project_dir = os.path.dirname(current_project)

        # Save currently opened project if one is open
        if current_project:
            QgsProject.instance().write()

        # Clear current project
        QgsProject.instance().clear()

        # Data paths from QLineEdits
        dataPaths = {
            'UNL': self.leUNL.text(),
            'SLMN': self.leSLMN.text(),
            'POCH': self.lePOCH.text(),
            'KSLMN': self.leKSLMN.text(),
            'mLAS': self.leSzkice.text()
        }

        unzip_directories = {
            'UNL': os.path.join('001_UNL','unl'),
            'SLMN': '002_SLMN',
            'POCH': '003_POCH',
            'KSLMN': '004_KontroleSLMN',
            'mLAS': '005_ObiektySzkicownika'
        }

        #Unzip files into their respective directories
        for key, path in dataPaths.items():
            if path:  #Only process non-empty paths
                directory = os.path.join(project_dir, unzip_directories.get(key))
                if directory:
                    try:
                        if not os.path.exists(directory):
                            os.makedirs(directory)
                        QgsMessageLog.logMessage(f"Unzipping {path} into {directory}",
                                                 "LMN2QGIS", Qgis.Info)
                        self.unzip_file(path, directory, key)  #  Pass the key to handle UNL case
                    except Exception as e:
                        QgsMessageLog.logMessage(f"Error unzipping {path}: {e}",
                                                 "LMN2QGIS", Qgis.Critical)

        # Reload project if it was previously open
        if current_project:
            project_instance = QgsProject.instance()
            if not project_instance.read(current_project):
                QgsMessageLog.logMessage("Failed to reload the project file.","LMN2QGIS", Qgis.Critical)
            else:
                QgsMessageLog.logMessage("Project reloaded successfully.", "LMN2QGIS", Qgis.Info)

        # Get layer by name
        layer_name = 'a_oddz_pol'
        layer = QgsProject.instance().mapLayersByName(layer_name)

        if layer:
            layer = layer[0]
            extent = layer.extent()
            canvas = self.iface.mapCanvas()

            # Set the canvas extent to layer extent
            canvas.setExtent(extent)

            # Refresh canvas to update the view
            canvas.refresh()
        else:
            print(f"Layer '{layer_name}' not found.")

    def on_pbExport_clicked(self):
        QgsMessageLog.logMessage("on_pbExport_clicked - Start", "LMN2QGIS", Qgis.Info)

        project_directory = os.path.dirname(QgsProject.instance().fileName())

        data_to_export_directory = os.path.join(project_directory, "002_SLMN")
        export_directory = os.path.join(project_directory, "000_DoImportuSILP")

        if not os.path.isdir(export_directory):
            os.makedirs(export_directory)

        if not os.path.isdir(data_to_export_directory):
            self.show_popup("Błąd", "Folder 002_SLMN nie istnieje!")
            return

        if len(os.listdir(data_to_export_directory)) == 0:
            self.show_popup("Błąd", "Folder 002_SLMN jest pusty!")
            return

        shapefile_names = {
            "a_pnsw_pow", "a_oddz_pol", "a_wydz_pol",
            "a_uzyt_pol", "a_dzew_pol", "a_les_pol"
        }

        choice = self.show_decision_msg_box("Export do zip", f"Wybierz 'Eksportuj wybrane' aby wyeksportować paczkę zawierającą tylko pliki warstw\n\n{shapefile_names}.\n\nOpcja 'Pełny eksport' utworzy paczkę zawierającą wszystkie pliki SLMN", "Eksportuj wybrane", "Pełny eksport")

        time_tag = datetime.now().strftime("%Y%m%d_%H.%M.%S.zip")
        zip_file_path = os.path.join(export_directory, time_tag)

        if choice == False:  # User chose to zip entire folder
            QgsMessageLog.logMessage(f"Zipping entire folder: {data_to_export_directory}", "LMN2QGIS", Qgis.Info)
            with zipfile.ZipFile(zip_file_path, "w", zipfile.ZIP_DEFLATED) as zipf:
                for root, _, files in os.walk(data_to_export_directory):
                    for file in files:
                        file_path = os.path.join(root, file)
                        arcname = os.path.relpath(file_path, data_to_export_directory)
                        zipf.write(file_path, arcname)
                        QgsMessageLog.logMessage(f"Added file: {arcname}", "LMN2QGIS", Qgis.Info)

        else:  # User chose to zip specific shapefiles
            QgsMessageLog.logMessage("Zipping only selected SHP files...", "LMN2QGIS", Qgis.Info)
            with zipfile.ZipFile(zip_file_path, "w", zipfile.ZIP_DEFLATED) as zipf:
                added_files = 0
                for root, _, files in os.walk(data_to_export_directory):
                    for file in files:
                        file_base, ext = os.path.splitext(file)
                        if ext.lower() in {".shp", ".dbf", ".shx", ".prj"} and file_base.lower() in shapefile_names:
                            file_path = os.path.join(root, file)
                            arcname = os.path.relpath(file_path, data_to_export_directory)
                            zipf.write(file_path, arcname)
                            added_files += 1
                            QgsMessageLog.logMessage(f"Added file: {arcname}", "LMN2QGIS", Qgis.Info)

                if added_files == 0:
                    QMessageBox.warning(None, "Błąd", "Nie znaleziono plików SHP do eksportu!")
                    return

        QgsMessageLog.logMessage(f"Zip file created: {zip_file_path}", "LMN2QGIS", Qgis.Info)

        #
        if os.name == "nt":  # Windows
            subprocess.call(("cmd", "/c", "start", "", export_directory))
        elif os.name == "posix":  # macOS / Linux
            subprocess.call(("open", export_directory)) if sys.platform == "darwin" else subprocess.call(("xdg-open", export_directory))

        QgsMessageLog.logMessage("on_pbExport_clicked - End", "LMN2QGIS", Qgis.Info)


    def on_pbRecalcId_clicked(self):

        hint_msg = "Ta funkcja zaktualizuje pole 'id' wskazanych warstw stosując wyrażenie '$id + 1'.\nZaleca się uruchomienie tej funkcji przed importem do SILP jeśli" \
                   "w trakcie edycji warstwy usuwano lub dodawano obiekty.\nW przeciwnym razie w trakcie importu może wystąpić błąd.\nCzy chcesz kontynuować? Przeliczanie id" \
                   " w zależności od komputera może potrwać kilka a nawet kilkanaście minut."

        reply = self.show_decision_msg_box('Przelicz ID', hint_msg)

        if reply == False:
            return

        layer_names = ["a_pnsw_pow", "a_oddz_pol", "a_wydz_pol", "a_uzyt_pol", "a_dzew_pol", "a_les_pol"]
        available_layers = {name: QgsProject.instance().mapLayersByName(name)[0] for name in layer_names if
                            QgsProject.instance().mapLayersByName(name)}

        if not available_layers:
            QMessageBox.critical(self, "Błąd", "Nie znaleziono właściwych warstw w projekcie.")
            return


        dialog = QDialog(self)
        dialog.setWindowTitle("Wybierz warstwy")
        layout = QVBoxLayout()

        checkboxes = {}
        for layer_name, layer in available_layers.items():
            checkbox = QCheckBox(layer_name)
            checkbox.setChecked(False)
            checkboxes[layer_name] = checkbox
            layout.addWidget(checkbox)

        ok_button = QPushButton("OK")
        layout.addWidget(ok_button)
        dialog.setLayout(layout)

        def accept_selection():
            dialog.accept()

        ok_button.clicked.connect(accept_selection)
        dialog.exec_()

        selected_layers = [available_layers[name] for name, checkbox in checkboxes.items() if checkbox.isChecked()]

        if not selected_layers:
            QMessageBox.warning(self, "Nie wskazano warstw", "Nie wskazano warstw do aktualizacji.")
            return

        expr = QgsExpression("$id + 1")

        for layer in selected_layers:
            if "id" not in [field.name() for field in layer.fields()]:
                QMessageBox.critical(self, "Błąd", f"Warstwa '{layer.name()}' nie zawiera pola 'id'.")
                return

            layer.startEditing()

            feature_count = layer.featureCount()
            if feature_count == 0:
                QgsMessageLog.logMessage(f"Layer {layer.name()} is empty.", "RecalculateID", Qgis.Warning)
                continue

            # Init progress bar
            progress = QProgressDialog(f"Aktualizacja warstwy {layer.name()}...", "Przerwij", 0, feature_count, self)
            progress.setWindowTitle("Postęp")
            progress.setModal(True)
            progress.show()

            context = QgsExpressionContext()
            context.appendScopes(QgsExpressionContextUtils.globalProjectLayerScopes(layer))

            updated_count = 0
            for feature in layer.getFeatures(QgsFeatureRequest()):
                if progress.wasCanceled():
                    QMessageBox.warning(self, "Anulowano operację", "Operacja została wstrzymana przez użytkownika.")
                    layer.rollBack()
                    return

                context.setFeature(feature)
                new_id = expr.evaluate(context)
                layer.changeAttributeValue(feature.id(), layer.fields().lookupField("id"), new_id)

                updated_count += 1
                progress.setValue(updated_count)  # Update progress bar

            # Commit edits
            layer.commitChanges()
            QgsMessageLog.logMessage(
                f"Updated 'id' field in {layer.name()} ({updated_count}/{feature_count} features).", "RecalculateID",
                Qgis.Info)

        QMessageBox.information(self, "Sukces", "Przeliczono id dla wskazanych warstw.")



    ###Plugin init functions

    # at plugin start checks if there is any project with unsaved changes open.
    # if yes it will bring up a dialog and ask user if he wants to save project
    # if yes proceeds to save_project
    # if no continues to project_creation_wizard
    def check_if_project_open(self):
        if QgsProject.instance().isDirty():
            msg_box = QtWidgets.QMessageBox()
            msg_box.setWindowTitle("Wykryto niezapisane zmiany")
            msg_box.setText("Wykryto nie zapisane zmiany, czy chcesz zapisać obecny projekt? Nie zapisanie projektu może skutkować utratą danych.")

            tak_zapisz_button = msg_box.addButton("Tak zapisz", QtWidgets.QMessageBox.AcceptRole)
            nie_zapisuj_button = msg_box.addButton("Nie zapisuj", QtWidgets.QMessageBox.RejectRole)
            msg_box.setDefaultButton(nie_zapisuj_button)
            msg_box.exec()

            if msg_box.clickedButton() == tak_zapisz_button:
                return self.save_project(QgsProject.instance())
            else:
                return self.project_creation_wizard()
        elif not QgsProject.instance().fileName():
            return self.project_creation_wizard()
        return True

    def save_project(self, project):
        if project.fileName():
            project.write()
            QgsMessageLog.logMessage(f"Project saved at: {project.fileName()}", "LMN2QGIS", Qgis.Info)
            return True
        else:
            options = QtWidgets.QFileDialog.Options()

            # Prompt user to select a file to save the project

            file_name, _ = QtWidgets.QFileDialog.getSaveFileName(
                None,
                "Save Project",
                "",
                "QGIS Project Files (*.qgz *.qgs);;All Files (*)",
                options=options
            )

            if file_name:  # If the user selected a file
                project.write(file_name)  # Save the project to the selected file
                QgsMessageLog.logMessage(f"Project saved at: {file_name}", "LMN2QGIS", Qgis.Info)
                return True

            else:
                self.check_if_project_open()

### Project builder functions

    def create_working_directory(self):

        QgsMessageLog.logMessage(f"def project_creation_wizard - user designates new working directory", "LMN2QGIS", Qgis.Info)
        self.show_popup("Nie odnaleziono katalogu roboczego", r"Wskaż katalog, w którym przechowywane będą projekty. Zaleca się aby katalog znajdował się na profilu użytkowniku np. 'C:\Użytkownicy\nazwa.użytkownika\Dokumenty\AktualizacjaLMN'")

        QgsMessageLog.logMessage("User prompted to create/select working directory", "LMN2QGIS", Qgis.Info)

        working_directory = QFileDialog.getExistingDirectory(
            None,
            "Wybierz lub utwórz katalog roboczy",
            os.path.expanduser("~"),
            QFileDialog.ShowDirsOnly | QFileDialog.DontUseNativeDialog
        )

        if not working_directory:
            QgsMessageLog.logMessage("User canceled directory selection.", "LMN2QGIS", Qgis.Warning)
            return False

        # Ensure directory exists (in case user typed a name manually)
        try:
            if not os.path.exists(working_directory):
                os.makedirs(working_directory)

            self.storage_directory = os.path.join(working_directory, "000_Exporty_z_SILP")
            os.makedirs(self.storage_directory, exist_ok=True)

            for subdir in ["001_UNL", "002_SLMN", "003_POCH", "004_KontroleSLMN", "005_ObiektySzkicownika"]:
                os.makedirs(os.path.join(self.storage_directory, subdir), exist_ok=True)

            QMessageBox.information(None, "Sukces", f"Katalog roboczy '{working_directory}' został utworzony lub wybrany.")
            return working_directory

        except OSError as e:
            QgsMessageLog.logMessage(f"Error creating directory: {e}", "LMN2QGIS", Qgis.Critical)
            QMessageBox.critical(None, "Błąd", f"Nie udało się utworzyć katalogu: {e}")
            return False

    def create_project(self, working_directory):

        current_date = datetime.now().strftime("%d-%m-%Y")
        max_attempts = 10

        for attempt in range(max_attempts):
            unique_id = str(uuid.uuid4())[:4]
            project_directory = os.path.join(working_directory, f"Aktualizacja_{current_date}_{unique_id}")

            if not os.path.exists(project_directory):
                try:
                    os.makedirs(project_directory)
                    break
                except OSError as e:
                    QgsMessageLog.logMessage(f"Błąd tworzenia katalogu: {e}", "LMN2QGIS", Qgis.Critical)
                    QMessageBox.critical(
                        self.iface.mainWindow(),
                        "Błąd",
                        "Nie udało się utworzyć katalogu projektu."
                    )
                    return False
        else:
            QMessageBox.critical(
                self.iface.mainWindow(),
                "Błąd",
                "Nie udało się wygenerować unikatowej nazwy projektu."
            )
            return False

        config_directory = os.path.join(os.path.dirname(__file__), "config")
        source_file = os.path.join(config_directory, "Aktualizacja.qgz")
        project_name = f"Aktualizacja_{current_date}_{unique_id}.qgz"
        project_path = os.path.join(project_directory, project_name)

        try:
            shutil.copy(source_file, project_path)
        except FileNotFoundError:
            QgsMessageLog.logMessage("Plik szablonu nie znaleziony w katalogu konfiguracyjnym.", "LMN2QGIS", Qgis.Critical)
            QMessageBox.critical(
                self.iface.mainWindow(),
                "Błąd",
                "Plik szablonu projektu nie został znaleziony. Sprawdź konfigurację wtyczki."
            )
            return False
        except Exception as e:
            QgsMessageLog.logMessage(f"Błąd kopiowania pliku: {e}", "LMN2QGIS", Qgis.Critical)
            return False

        subdirectories = ["001_UNL", "002_SLMN", "003_POCH", "004_KontroleSLMN", "005_ObiektySzkicownika"]
        for subdir in subdirectories:
            try:
                os.makedirs(os.path.join(project_directory, subdir), exist_ok=True)
            except OSError as e:
                QgsMessageLog.logMessage(f"Błąd tworzenia podkatalogu {subdir}: {e}", "LMN2QGIS", Qgis.Critical)
                return False

        QgsMessageLog.logMessage(f"Utworzono nowy projekt: {project_directory}", "LMN2QGIS", Qgis.Info)
        self.open_project(project_path, project_directory)
        return True

    def select_project(self, working_directory):

        project_path, _ = QFileDialog.getOpenFileName(
            self.iface.mainWindow(),
            "Wybierz istniejący projekt",
            working_directory,
            "QGIS Projects (*.qgz)"
        )

        if project_path:
            project_directory = os.path.dirname(project_path)
            self.open_project(project_directory, None)
            return True

        return False

    def open_project(self, project_path, project_directory):

        if os.path.exists(project_path):
            QgsProject.instance().read(project_path)
            if project_directory:
                os.startfile(project_directory)  # Opens directory in file explorer
            QgsMessageLog.logMessage(f"Otworzono projekt: {project_path}", "LMN2QGIS", Qgis.Info)
        else:
            QMessageBox.critical(
                self.iface.mainWindow(),
                "Błąd",
                "Nie udało się otworzyć projektu. Plik nie istnieje."
            )

    def project_creation_wizard(self):
        config_directory = os.path.join(os.path.dirname(__file__), "config")
        config_file = os.path.join(config_directory, "workingDirectory.txt")

        if not os.path.exists(config_file):
            QgsMessageLog.logMessage("Brak pliku konfiguracji, tworzenie workingDirectory.txt", "LMN2QGIS", Qgis.Info)
            with open(config_file,'w') as f:
                f.write("")

        with open(config_file, 'r') as f:
            working_directory = f.read().strip() or None

        if not working_directory or not os.path.exists(working_directory):
            working_directory = self.create_working_directory()
            if not working_directory:
                return False
            with open(config_file, 'w') as f:
                f.write(working_directory)

        projects = [d for d in os.listdir(working_directory) if os.path.isdir(os.path.join(working_directory, d)) and d.startswith("Aktualizacja_")]
        if projects:
            if self.show_decision_msg_box("Kreator projektów", "Czy chcesz stworzyć nowy projekt?"):
                return self.create_project(working_directory)
            elif self.show_decision_msg_box("Kreator projektów", "Czy chcesz otworzyć istniejący projekt?"):
                return self.select_project(working_directory)
            else:
                return False
        else:
            return self.create_project(working_directory)

    # Utilities

    def show_popup(self, title, message):
        QMessageBox.warning(self.iface.mainWindow(), title, message)

    def show_decision_msg_box(self, title, message, Yes_role = "Tak", No_role = "Nie"):
        msg_box = QMessageBox()
        msg_box.setWindowTitle(title)
        msg_box.setText(message)

        tak_button = msg_box.addButton(Yes_role, QMessageBox.AcceptRole)
        nie_button = msg_box.addButton(No_role, QMessageBox.RejectRole)

        msg_box.exec()

        if msg_box.clickedButton() == tak_button:
            return True
        else:
            return False

